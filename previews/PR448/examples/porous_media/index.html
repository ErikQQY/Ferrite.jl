<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Porous media · Ferrite.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../manual/fe_intro/">Introduction to FEM</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../manual/assembly/">Assembly</a></li><li><a class="tocitem" href="../../manual/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../manual/grid/">Grid</a></li><li><a class="tocitem" href="../../manual/export/">Export</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../heat_equation/">Heat Equation</a></li><li><a class="tocitem" href="../postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz equation</a></li><li><a class="tocitem" href="../incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../threaded_assembly/">Threaded Assembly</a></li><li><a class="tocitem" href="../plasticity/">von Mises plasticity</a></li><li><a class="tocitem" href="../transient_heat_equation/">Time Dependent Problems</a></li><li><a class="tocitem" href="../landau/">Ginzburg-Landau model energy minimization</a></li><li><a class="tocitem" href="../linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../quasi_incompressible_hyperelasticity/">Nearly Incompressible Hyperelasticity</a></li><li><a class="tocitem" href="../ns_vs_diffeq/">Incompressible Navier-Stokes Equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../computational_homogenization/">Computational homogenization</a></li><li class="is-active"><a class="tocitem" href>Porous media</a><ul class="internal"><li><a class="tocitem" href="#Theory-of-porous-media"><span>Theory of porous media</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#porous-media-plain-program"><span>Plain program</span></a></li></ul></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Porous media</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Porous media</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/porous_media.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Porous-media"><a class="docs-heading-anchor" href="#Porous-media">Porous media</a><a id="Porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Porous-media" title="Permalink"></a></h1><p>Porous media is a two-phase material, consisting of solid parts and a liquid occupying the pores inbetween. Using the porous media theory, we can model such a material without explicitly resolving the microstructure, but by considering the interactions between the solid and liquid. In this example, we will additionally consider larger linear elastic solid aggregates that are impermeable. Hence, there is no liquids in these particles and the only unknown variable is the displacement field <code>:u</code>. In the porous media, denoted the matrix, we have both the displacement field, <code>:u</code>, as well as the liquid pressure, <code>:p</code>, as unknown. The computational domain is shown below</p><p><img src="../porous_media.svg" alt="Computational domain"/> <img src="../porous_media.gif" alt="Pressure evolution."/></p><h2 id="Theory-of-porous-media"><a class="docs-heading-anchor" href="#Theory-of-porous-media">Theory of porous media</a><a id="Theory-of-porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-of-porous-media" title="Permalink"></a></h2><p>The strong forms for the mass balance of the liquid is given as</p><p class="math-container">\[   \frac{\mathrm{d}_\mathrm{s} n \rho_\mathrm{l}}{\mathrm{d}t}
   + \mathrm{div}\left(n \rho_\mathrm{l} \tilde{\boldsymbol{v}}_\mathrm{l}\right)
   + n \rho_\mathrm{l} \mathrm{tr}(\boldsymbol{\dot{\epsilon}}) = 0\]</p><p>where <span>$\mathrm{d}_\mathrm{s}/\mathrm{d}t$</span> is the time of a quantity following the solid skeleton motion, described by the displacements <span>$\boldsymbol{u}$</span>. <span>$n$</span> is the porosity (i.e. volume fraction of pores, assumed constant due to small strains), <span>$\rho_\mathrm{l}$</span> is the liquid density, <span>$\tilde{\boldsymbol{v}}_\mathrm{l}$</span> is the liquid velocity relative to the solid skeleton motion, and <span>$\boldsymbol{\epsilon}$</span> is the strain tensor for the solid skeleton, <span>$\boldsymbol{\epsilon}=\left[\mathrm{grad}(\boldsymbol{u})\right]^\mathrm{sym}$</span>. The functions <span>$\mathrm{div}()$</span> and <span>$\mathrm{grad}()$</span> represent the divergence and gradient, respectively. Furthermore, the balance of momentum is given as</p><p class="math-container">\[   \mathrm{div}(\boldsymbol{\sigma}) = \boldsymbol{0}\]</p><p>where <span>$\boldsymbol{\sigma}$</span> is the Cauchy stress. For simplicity in this example, body loads, e.g. due to gravity, are not included.</p><h3 id="Constitutive-equations"><a class="docs-heading-anchor" href="#Constitutive-equations">Constitutive equations</a><a id="Constitutive-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Constitutive-equations" title="Permalink"></a></h3><p>Darcy&#39;s law, excluding gravity loads, is used for the fluid flow through the porous media</p><p class="math-container">\[   n \tilde{\boldsymbol{v}}_\mathrm{l} = -[k/\mu] \mathrm{grad}(p)\]</p><p>A constant fluid bulk modulus, <span>$K_\mathrm{l}$</span>, gives the relationship between fluid pressure, <span>$p$</span>, and density, <span>$\rho_\mathrm{l}$</span>, as</p><p class="math-container">\[\dot{\rho}_\mathrm{l} = \frac{\rho_\mathrm{l}}{K_\mathrm{l}} \dot{p}\]</p><p>Finally, we use the most simple Terzaghi effective stress combined with linear isotropic elasticity</p><p class="math-container">\[\boldsymbol{\sigma} = \boldsymbol{\mathrm{E}}:\boldsymbol{\epsilon} - p\boldsymbol{I} = 2G \boldsymbol{\epsilon}^\mathrm{dev} + 3 K \boldsymbol{\epsilon}^\mathrm{vol} - p \boldsymbol{I}\]</p><h3 id="Weak-form"><a class="docs-heading-anchor" href="#Weak-form">Weak form</a><a id="Weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-form" title="Permalink"></a></h3><p>From the above strong form with constitutive equations (and including boundary conditions), we obtain the following weak forms for the mass balance,</p><p class="math-container">\[  \int_\Gamma \delta p \tilde{\boldsymbol{v}}_\mathrm{l} \cdot \boldsymbol{n} \mathrm{d}\Gamma =
  \int_\Omega \mathrm{grad}(\delta p) \cdot \mathrm{grad}(p) [k/n] \mathrm{d} \Omega +
  \int_\Omega \delta p \left[\dot{p}/K_\mathrm{l} + \mathrm{div}\left(\dot{\boldsymbol{u}}\right)\right] \mathrm{d}\Omega\]</p><p>and for the momentum balance</p><p class="math-container">\[  \int_\Gamma \boldsymbol{\delta u} \cdot \boldsymbol{t} \mathrm{d} \Gamma =
  \int_\Omega \mathrm{grad}\left(\boldsymbol{\delta u}\right) : \left[ \boldsymbol{\mathrm{E}} : \mathrm{grad}(\boldsymbol{u}) - p \boldsymbol{I}\right] \mathrm{d} \Omega\]</p><h3 id="Finite-element-form"><a class="docs-heading-anchor" href="#Finite-element-form">Finite element form</a><a id="Finite-element-form-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-form" title="Permalink"></a></h3><p>Discretizing in space using finite elements, we obtain the matrix equation <span>$f_{i}^\mathrm{ext}=K_{ij} a_j + L_{ij} \dot{a}_j$</span> where <span>$f^\mathrm{ext}$</span> are the external &quot;forces&quot;, <span>$K$</span> the stiffness matrix, <span>$a$</span> the unknown degrees of freedom, <span>$L$</span> the (dampening) matrix that is multiplied with the rate of the unknown degrees of freedom. For each relevant part, we can specify these matrices and vectors as</p><p class="math-container">\[\begin{align*}
   K_{ij}^\mathrm{pp} &amp;= \int_\Omega \mathrm{grad}\left(\delta N^\mathrm{p}_i\right)\cdot \left[\frac{k}{n}\mathrm{grad}\left(N^\mathrm{p}_j\right)\right] \mathrm{d}\Omega \\
   L_{ij}^\mathrm{pp} &amp;= \int_\Omega \delta N_i^\mathrm{p} N_j^\mathrm{p}/K_\mathrm{l} \mathrm{d}\Omega \\
   L_{ij}^\mathrm{pu} &amp;= \int_\Omega \delta N_i^\mathrm{p} \mathrm{div}\left(\boldsymbol{N}_j^\mathrm{u}\right) \mathrm{d}\Omega \\
   K_{ij}^\mathrm{uu} &amp;= - \int_\Omega \mathrm{grad}\left(\boldsymbol{\delta N}^\mathrm{u}_i\right) : \boldsymbol{\mathrm{E}} : \mathrm{grad}\left(\boldsymbol{N}_j^\mathrm{u}\right) \mathrm{d} \Omega \\
   K_{ij}^\mathrm{up} &amp;= \int_\Omega \mathrm{div}\left(\boldsymbol{\delta N}_i^\mathrm{u}\right) N_j^\mathrm{p} \mathrm{d}\Omega \\
   f_{i}^\mathrm{p,ext} &amp;= \int_\Gamma \delta N_i^\mathrm{p} \tilde{\boldsymbol{v}}_\mathrm{l} \cdot \boldsymbol{n} \mathrm{d}\Gamma\\
   f_{i}^\mathrm{u,ext} &amp;= -\int_\Gamma \boldsymbol{\delta N}_i^\mathrm{u} \cdot \boldsymbol{t} \mathrm{d} \Gamma
\end{align*}\]</p><p>This results in the equation system</p><p class="math-container">\[\begin{align*}
f_{i}^\mathrm{p,ext} &amp;= K_{ij}^\mathrm{pp} a_{j}^\mathrm{p} + L_{ij}^\mathrm{pp} \dot{a}_j^\mathrm{p} + L_{ij}^\mathrm{pu} \dot{a}_j^\mathrm{u} \\
f_{j}^\mathrm{u,ext} &amp;= K_{ij}^\mathrm{up} a_{j}^\mathrm{p} + K_{ij}^\mathrm{uu} a_j^\mathrm{u}
\end{align*}\]</p><p>where the subscripts <span>$\mathrm{p}$</span> and <span>$\mathrm{u}$</span> gives the part of the vector pertinent to that degree of freedom (pressure or displacement). The time discretized form of the above equation becomes</p><p class="math-container">\[\begin{align*}
\Delta t f_{i}^\mathrm{p,ext} + L_{ij}^\mathrm{pp} a_j^\mathrm{p,old} + L_{ij}^\mathrm{pu} a_j^\mathrm{u,old} &amp;= \Delta t K_{ij}^\mathrm{pp} a_{j}^\mathrm{p} + L_{ij}^\mathrm{pp} a_j^\mathrm{p} + L_{ij}^\mathrm{pu} a_j^\mathrm{u} \\
f_{j}^\mathrm{u,ext} &amp;= K_{ij}^\mathrm{up} a_{j}^\mathrm{p} + K_{ij}^\mathrm{uu} a_j^\mathrm{u}
\end{align*}\]</p><p>As the matrices are constant, it suffices to assemble them once and reuse for each time step. However, in this example we assemble in each time step, calculating only one stiffness matrix. The contributions from the old values, on the left hand side, are considered as external loads. This avoids having two global matrices, simplifying the present example and making it more suitable to consider nonlinear problems. With all the theory completed, let&#39;s start implementing a solution to this problem in Ferrite. Material parameters are hard-coded in for simplicity.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>We now solve the problem step by step. The full program with fewer comments is found in the final <a href="#porous-media-plain-program">section</a></p><p>Required packages</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors</code></pre><h3 id="Elasticity"><a class="docs-heading-anchor" href="#Elasticity">Elasticity</a><a id="Elasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Elasticity" title="Permalink"></a></h3><p>We then define the stiffness tensor <span>$\boldsymbol{\mathrm{E}}$</span> for linear isotropic elasticity and plane strain</p><pre><code class="language-julia hljs">function elastic_stiffness(E=20.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    return 2G*I4dev + K*I4vol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">elastic_stiffness (generic function with 3 methods)</code></pre><h3 id="Element-routines"><a class="docs-heading-anchor" href="#Element-routines">Element routines</a><a id="Element-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Element-routines" title="Permalink"></a></h3><p>Next, we define the element routines. First for the case of the linear elastic impermeable solid aggregates In this simplified example, we dispatch on the cellvalues which are only <code>CellVectorValues</code> for the solid aggregates. Note that the unused inputs here are used for the porous matrix below.</p><pre><code class="language-julia hljs">function element_routine!(Ke, _, cell, _, cv::CellVectorValues, _, _)
    reinit!(cv, cell)
    n_basefuncs = getnbasefunctions(cv)
    fill!(Ke, 0)
    dσdϵ = elastic_stiffness()
    for q_point in 1:getnquadpoints(cv)
        dΩ = getdetJdV(cv, q_point)
        for i in 1:n_basefuncs
            δ∇N = shape_symmetric_gradient(cv, q_point, i)
            for j in 1:n_basefuncs
                ∇N = shape_symmetric_gradient(cv, q_point, j)
                Ke[i, j] += δ∇N ⊡ dσdϵ ⊡ ∇N * dΩ
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">element_routine! (generic function with 1 method)</code></pre><p>Due to the two fields, <code>:p</code> and <code>:u</code>, as well as more physics, in the porous matrix, we require a few more inputs to get the element force and stiffness. We dispatch on the cellvalues being a tuple of <code>CellVectorValues</code> and <code>CellScalarValues</code>.</p><pre><code class="language-julia hljs">function element_routine!(Ke, fext, cell, fh::FieldHandler, cvs::Tuple{CellVectorValues, CellScalarValues}, a_old, Δt)
    # Setup cellvalues and give easier names
    reinit!.(cvs, (cell,))
    cv_u, cv_p = cvs
    num_u_basefuncs, num_p_basefuncs = getnbasefunctions.(cvs)

    # Check that cellvalues are compatible with each other (should have same quadrature rule)
    @assert getnquadpoints(cv_u) == getnquadpoints(cv_p)

    # Reset element stiffness and external force
    fill!(Ke, 0.0)
    fill!(fext, 0.0)

    # Assign views to the matrix and vector parts
    udofs = dof_range(fh, :u)
    pdofs = dof_range(fh, :p)
    Kuu = @view Ke[udofs, udofs]
    Kpu = @view Ke[pdofs, udofs]
    Kup = @view Ke[udofs, pdofs]
    Kpp = @view Ke[pdofs, pdofs]
    # fu = @view fext[udofs]    # Not used, traction is zero or displacements prescribed
    fp = @view fext[pdofs]
    au_old = @view a_old[udofs]
    ap_old = @view a_old[pdofs]

    # Material parameters
    μ = 1.e-4       # [Ns/mm^2] Dynamic viscosity
    k = 5.0e-6      # [mm^2] Intrinsic permeability
    k_darcy = k/μ
    n = 0.8         # [-] Porosity
    K_liquid = 2.e3 # [MPa] Liquid bulk modulus
    dσdϵ = elastic_stiffness()

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        dΩ = getdetJdV(cv_u, q_point)
        # Variation of u_i
        for i in 1:num_u_basefuncs
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, i)
            div_δNu = shape_divergence(cv_u, q_point, i)
            for j in 1:num_u_basefuncs
                ∇Nu = shape_symmetric_gradient(cv_u, q_point, j)
                Kuu[i, j] -= ∇δNu ⊡ dσdϵ ⊡ ∇Nu * dΩ
            end
            for j in 1:num_p_basefuncs
                Np = shape_value(cv_p, q_point, j)
                Kup[i, j] += div_δNu * Np
            end
        end
        # Variation of p_i
        for i in 1:num_p_basefuncs
            δNp = shape_value(cv_p, q_point, i)
            ∇δNp = shape_gradient(cv_p, q_point, i)
            for j in 1:num_u_basefuncs
                div_Nu = shape_divergence(cv_u, q_point, j)
                Lpu_ij = δNp*div_Nu*dΩ
                Kpu[i,j] += Lpu_ij
                fp[i] += Lpu_ij*au_old[j]
            end
            for j in 1:num_p_basefuncs
                ∇Np = shape_gradient(cv_p, q_point, j)
                Np = shape_value(cv_p, q_point, j)
                Kpp_ij = (k_darcy/n) * ∇δNp ⋅ ∇Np * dΩ
                Lpp_ij = δNp*Np/K_liquid
                Kpp[i,j] += Δt*Kpp_ij + Lpp_ij
                fp[i] += Lpp_ij*ap_old[j]
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">element_routine! (generic function with 2 methods)</code></pre><h3 id="Assembly"><a class="docs-heading-anchor" href="#Assembly">Assembly</a><a id="Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly" title="Permalink"></a></h3><p>In order to assemble the contribution from each cell, we first loop over each field with the following function.</p><pre><code class="language-julia hljs">function doassemble!(K, f, dh, cvs, a_old, Δt)
    assembler = start_assemble(K, f)
    for (fh, cv) in zip(dh.fieldhandlers, cvs)
        doassemble!(assembler, dh, cv, fh, a_old, Δt)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doassemble! (generic function with 1 method)</code></pre><p>When calling the <code>doassemble!</code> with a specific <code>FieldHandler</code>, we can then loop over all cells in its cellset. This ensures that the <code>CellIterator</code> and <code>element_routine!</code> is type stable.</p><pre><code class="language-julia hljs">function doassemble!(assembler, dh, cv, fh::FieldHandler, a_old, Δt)
    n = ndofs_per_cell(dh, first(fh.cellset))
    Ke = zeros(n,n)
    fe = zeros(n)
    for cell in CellIterator(dh, collect(fh.cellset))
        element_routine!(Ke, fe, cell, fh, cv, a_old[celldofs(cell)], Δt)
        assemble!(assembler, celldofs(cell), Ke, fe)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doassemble! (generic function with 2 methods)</code></pre><h3 id="Mesh-import"><a class="docs-heading-anchor" href="#Mesh-import">Mesh import</a><a id="Mesh-import-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import" title="Permalink"></a></h3><p>In this example, we import the mesh from the Abaqus input file, <a href="../porous_media_0p25.inp"><code>porous_media_0p25.inp</code></a> using <code>FerriteMeshParser</code>&#39;s <code>get_ferrite_grid</code> function. We then create one cellset for each phase (solid and porous) for each element type. These 4 sets will later be used in their own <code>FieldHandler</code></p><pre><code class="language-julia hljs">function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media_0p25.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    return grid
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_grid (generic function with 1 method)</code></pre><h3 id="Problem-setup"><a class="docs-heading-anchor" href="#Problem-setup">Problem setup</a><a id="Problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-setup" title="Permalink"></a></h3><p>Define the finite element interpolation, integration, and boundary conditions.</p><pre><code class="language-julia hljs">function setup_problem(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()
    ip4_lin = Lagrange{dim, RefCube, 1}()
    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()
    ip4_quad = Lagrange{dim, RefCube, 2}()
    qr3 = QuadratureRule{dim, RefTetrahedron}(1)
    qr4 = QuadratureRule{dim, RefCube}(2)

    # Setup the MixedDofHandler
    dh = MixedDofHandler(grid)
    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,&quot;solid3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,&quot;solid4&quot;)))
    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,&quot;porous3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,&quot;porous4&quot;)))
    close!(dh)

    # Setup cellvalues with the same order as the FieldHandlers in the dh
    # - Linear displacement elements in the solid domain
    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain
    cv = ( CellVectorValues(qr3, ip3_lin),
           CellVectorValues(qr4, ip4_lin),
           (CellVectorValues(qr3, ip3_quad, ip3_lin), CellScalarValues(qr3, ip3_lin)),
           (CellVectorValues(qr4, ip4_quad, ip4_lin), CellScalarValues(qr4, ip4_lin)) )

    # Add boundary conditions, use code from PR427.jl to make more general
    ch = ConstraintHandler(dh);
    # With #PR427 (keep code for if/when it is merged)
    # add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    # add!(ch, Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    # add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    # With master (only works if no tri-elements on boundary)
    add!(ch, dh.fieldhandlers[2], Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:u, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    close!(ch)
    return dh, ch, cv
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">setup_problem (generic function with 1 method)</code></pre><h3 id="Solving"><a class="docs-heading-anchor" href="#Solving">Solving</a><a id="Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Solving" title="Permalink"></a></h3><p>Given the <code>MixedDofHandler</code>, <code>ConstraintHandler</code>, and <code>CellValues</code>, we can solve the problem by stepping through the time history</p><pre><code class="language-julia hljs">function solve(dh, ch, cv; Δt=0.025, t_total=1.0)
    # Assemble stiffness matrix
    K = create_sparsity_pattern(dh);
    f = zeros(ndofs(dh))
    a = zeros(ndofs(dh))
    pvd = paraview_collection(&quot;porous_media.pvd&quot;);
    for (step, t) = enumerate(0:Δt:t_total)
        if t&gt;0
            doassemble!(K, f, dh, cv, a, Δt)
            update!(ch, t)
            apply!(K, f, ch)
            a .= K\f
        end
        vtk_grid(&quot;porous_media-$step&quot;, dh) do vtk
            vtk_point_data(vtk, dh, a)
            vtk_save(vtk)
            pvd[step] = vtk
        end
    end
    vtk_save(pvd);
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve (generic function with 1 method)</code></pre><p>Finally we call the functions to actually run the code</p><pre><code class="language-julia hljs">dh, ch, cv = setup_problem()
solve(dh, ch, cv)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">42-element Vector{String}:
 &quot;porous_media.pvd&quot;
 &quot;porous_media-1.vtu&quot;
 &quot;porous_media-2.vtu&quot;
 &quot;porous_media-3.vtu&quot;
 &quot;porous_media-4.vtu&quot;
 &quot;porous_media-5.vtu&quot;
 &quot;porous_media-6.vtu&quot;
 &quot;porous_media-7.vtu&quot;
 &quot;porous_media-8.vtu&quot;
 &quot;porous_media-9.vtu&quot;
 ⋮
 &quot;porous_media-33.vtu&quot;
 &quot;porous_media-34.vtu&quot;
 &quot;porous_media-35.vtu&quot;
 &quot;porous_media-36.vtu&quot;
 &quot;porous_media-37.vtu&quot;
 &quot;porous_media-38.vtu&quot;
 &quot;porous_media-39.vtu&quot;
 &quot;porous_media-40.vtu&quot;
 &quot;porous_media-41.vtu&quot;</code></pre><h2 id="porous-media-plain-program"><a class="docs-heading-anchor" href="#porous-media-plain-program">Plain program</a><a id="porous-media-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#porous-media-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../porous_media.jl"><code>porous_media.jl</code></a>.</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors

function elastic_stiffness(E=20.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    return 2G*I4dev + K*I4vol
end

function element_routine!(Ke, _, cell, _, cv::CellVectorValues, _, _)
    reinit!(cv, cell)
    n_basefuncs = getnbasefunctions(cv)
    fill!(Ke, 0)
    dσdϵ = elastic_stiffness()
    for q_point in 1:getnquadpoints(cv)
        dΩ = getdetJdV(cv, q_point)
        for i in 1:n_basefuncs
            δ∇N = shape_symmetric_gradient(cv, q_point, i)
            for j in 1:n_basefuncs
                ∇N = shape_symmetric_gradient(cv, q_point, j)
                Ke[i, j] += δ∇N ⊡ dσdϵ ⊡ ∇N * dΩ
            end
        end
    end
end

function element_routine!(Ke, fext, cell, fh::FieldHandler, cvs::Tuple{CellVectorValues, CellScalarValues}, a_old, Δt)
    # Setup cellvalues and give easier names
    reinit!.(cvs, (cell,))
    cv_u, cv_p = cvs
    num_u_basefuncs, num_p_basefuncs = getnbasefunctions.(cvs)

    # Check that cellvalues are compatible with each other (should have same quadrature rule)
    @assert getnquadpoints(cv_u) == getnquadpoints(cv_p)

    # Reset element stiffness and external force
    fill!(Ke, 0.0)
    fill!(fext, 0.0)

    # Assign views to the matrix and vector parts
    udofs = dof_range(fh, :u)
    pdofs = dof_range(fh, :p)
    Kuu = @view Ke[udofs, udofs]
    Kpu = @view Ke[pdofs, udofs]
    Kup = @view Ke[udofs, pdofs]
    Kpp = @view Ke[pdofs, pdofs]
    # fu = @view fext[udofs]    # Not used, traction is zero or displacements prescribed
    fp = @view fext[pdofs]
    au_old = @view a_old[udofs]
    ap_old = @view a_old[pdofs]

    # Material parameters
    μ = 1.e-4       # [Ns/mm^2] Dynamic viscosity
    k = 5.0e-6      # [mm^2] Intrinsic permeability
    k_darcy = k/μ
    n = 0.8         # [-] Porosity
    K_liquid = 2.e3 # [MPa] Liquid bulk modulus
    dσdϵ = elastic_stiffness()

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        dΩ = getdetJdV(cv_u, q_point)
        # Variation of u_i
        for i in 1:num_u_basefuncs
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, i)
            div_δNu = shape_divergence(cv_u, q_point, i)
            for j in 1:num_u_basefuncs
                ∇Nu = shape_symmetric_gradient(cv_u, q_point, j)
                Kuu[i, j] -= ∇δNu ⊡ dσdϵ ⊡ ∇Nu * dΩ
            end
            for j in 1:num_p_basefuncs
                Np = shape_value(cv_p, q_point, j)
                Kup[i, j] += div_δNu * Np
            end
        end
        # Variation of p_i
        for i in 1:num_p_basefuncs
            δNp = shape_value(cv_p, q_point, i)
            ∇δNp = shape_gradient(cv_p, q_point, i)
            for j in 1:num_u_basefuncs
                div_Nu = shape_divergence(cv_u, q_point, j)
                Lpu_ij = δNp*div_Nu*dΩ
                Kpu[i,j] += Lpu_ij
                fp[i] += Lpu_ij*au_old[j]
            end
            for j in 1:num_p_basefuncs
                ∇Np = shape_gradient(cv_p, q_point, j)
                Np = shape_value(cv_p, q_point, j)
                Kpp_ij = (k_darcy/n) * ∇δNp ⋅ ∇Np * dΩ
                Lpp_ij = δNp*Np/K_liquid
                Kpp[i,j] += Δt*Kpp_ij + Lpp_ij
                fp[i] += Lpp_ij*ap_old[j]
            end
        end
    end
end

function doassemble!(K, f, dh, cvs, a_old, Δt)
    assembler = start_assemble(K, f)
    for (fh, cv) in zip(dh.fieldhandlers, cvs)
        doassemble!(assembler, dh, cv, fh, a_old, Δt)
    end
end

function doassemble!(assembler, dh, cv, fh::FieldHandler, a_old, Δt)
    n = ndofs_per_cell(dh, first(fh.cellset))
    Ke = zeros(n,n)
    fe = zeros(n)
    for cell in CellIterator(dh, collect(fh.cellset))
        element_routine!(Ke, fe, cell, fh, cv, a_old[celldofs(cell)], Δt)
        assemble!(assembler, celldofs(cell), Ke, fe)
    end
end

function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media_0p25.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    return grid
end

function setup_problem(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ip3_lin = Lagrange{dim, RefTetrahedron, 1}()
    ip4_lin = Lagrange{dim, RefCube, 1}()
    ip3_quad = Lagrange{dim, RefTetrahedron, 2}()
    ip4_quad = Lagrange{dim, RefCube, 2}()
    qr3 = QuadratureRule{dim, RefTetrahedron}(1)
    qr4 = QuadratureRule{dim, RefCube}(2)

    # Setup the MixedDofHandler
    dh = MixedDofHandler(grid)
    push!(dh, FieldHandler([Field(:u, ip3_lin, dim)], getcellset(grid,&quot;solid3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_lin, dim)], getcellset(grid,&quot;solid4&quot;)))
    push!(dh, FieldHandler([Field(:u, ip3_quad, dim), Field(:p, ip3_lin, 1)], getcellset(grid,&quot;porous3&quot;)))
    push!(dh, FieldHandler([Field(:u, ip4_quad, dim), Field(:p, ip4_lin, 1)], getcellset(grid,&quot;porous4&quot;)))
    close!(dh)

    # Setup cellvalues with the same order as the FieldHandlers in the dh
    # - Linear displacement elements in the solid domain
    # - Taylor hood (quadratic displacement, linear pressure) and linear geometry in porous domain
    cv = ( CellVectorValues(qr3, ip3_lin),
           CellVectorValues(qr4, ip4_lin),
           (CellVectorValues(qr3, ip3_quad, ip3_lin), CellScalarValues(qr3, ip3_lin)),
           (CellVectorValues(qr4, ip4_quad, ip4_lin), CellScalarValues(qr4, ip4_lin)) )

    # Add boundary conditions, use code from PR427.jl to make more general
    ch = ConstraintHandler(dh);
    # With #PR427 (keep code for if/when it is merged)
    # add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    # add!(ch, Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    # add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    # With master (only works if no tri-elements on boundary)
    add!(ch, dh.fieldhandlers[2], Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:u, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    add!(ch, dh.fieldhandlers[4], Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    close!(ch)
    return dh, ch, cv
end

function solve(dh, ch, cv; Δt=0.025, t_total=1.0)
    # Assemble stiffness matrix
    K = create_sparsity_pattern(dh);
    f = zeros(ndofs(dh))
    a = zeros(ndofs(dh))
    pvd = paraview_collection(&quot;porous_media.pvd&quot;);
    for (step, t) = enumerate(0:Δt:t_total)
        if t&gt;0
            doassemble!(K, f, dh, cv, a, Δt)
            update!(ch, t)
            apply!(K, f, ch)
            a .= K\f
        end
        vtk_grid(&quot;porous_media-$step&quot;, dh) do vtk
            vtk_point_data(vtk, dh, a)
            vtk_save(vtk)
            pvd[step] = vtk
        end
    end
    vtk_save(pvd);
end

dh, ch, cv = setup_problem()
solve(dh, ch, cv)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../computational_homogenization/">« Computational homogenization</a><a class="docs-footer-nextpage" href="../../reference/quadrature/">Quadrature »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Wednesday 20 April 2022 09:38">Wednesday 20 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
